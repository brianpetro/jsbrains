<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: smart-chats/smart_chats_ui.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: smart-chats/smart_chats_ui.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { message_content_array_to_markdown } = require("../smart-chats/utils/message_content_array_to_markdown");
/**
 * Represents the user interface for SmartChat.
 * This class handles the rendering and interaction logic for the chat interface.
 */
class SmartChatsUI {
  /**
   * Creates an instance of SmartChatsUI.
   * @param {Object} env - The environment object containing configurations and utilities.
   * @param {HTMLElement} container - The HTML container element for the chat UI.
   */
  constructor(env, container) {
    this.env = env;
    this.main = this.env; // DEPRECATED
    this.container = container;
    this.templates = this.env.opts.templates;
  }

  /**
   * Provides a context for the view rendering. Should be overridden in subclasses.
   * @returns {Object} The context object for the view.
   */
  get view_context() { return { /* override */ }; }

  /**
   * Renders templates using the environment's rendering engine.
   * @param {...any} args - Arguments including template and data to render.
   * @returns {Promise&lt;string>} The rendered HTML string.
   */
  async render(...args) { return await this.env.ejs.render(...args); }

  /**
   * Displays a notice message in the console.
   * @param {string} message - The message to display.
   */
  show_notice(message) { console.log(message); }

  /**
   * Initializes the chat UI by clearing the container and rendering the initial chat template.
   */
  async init() {
    console.log("init SmartChatRenderer");
    console.log(this.container);
    this.container.innerHTML = "";
    console.log(this.env.chats.current);
    const data = await this.get_view_data();
    this.container.innerHTML = await this.render(this.templates.smart_chat, data, { context: this.view_context, rmWhitespace: true });
    this.post_process();
  }

  /**
   * Handles new user messages, updates the UI, and triggers rendering of typing indicator.
   * @param {string} user_input - The user's input message.
   */
  async new_user_message(user_input) {
    await this.new_message(user_input, "user");
    this.set_streaming_ux();
    await this.render_dotdotdot();
  }

  /**
   * Post-initialization processing, such as adding listeners and processing messages.
   */
  async post_process() {
    this.add_listeners();
    this.messages.forEach(this.message_post_process.bind(this));
  }

  /**
   * Placeholder for adding listeners. Should be overridden in subclasses.
   */
  add_listeners() { }

  /**
   * Placeholder for message post-processing. Should be overridden in subclasses.
   * @param {HTMLElement} msg_elm - The message element to process.
   */
  message_post_process(msg_elm) { }

  /**
   * Retrieves view data for rendering the chat interface.
   * @returns {Promise&lt;Object>} An object containing data for the view.
   */
  add_message_listeners(msg_elm) { } // OVERRIDE
  async get_view_data() {
    const data = {
      name: this.env.chats.current?.name || "UNTITLED CHAT",
      messages: await this.env.chats.current.get_messages_html(),
    };
    return data;
  }

  /**
   * Adds input listeners to the chat form for handling special keys and sending messages.
   */
  add_chat_input_listeners() {
    const chat_input = this.container.querySelector(".sc-chat-form textarea");
    chat_input.addEventListener("keydown", this.key_down_handler.bind(this));
    // add event listeners to buttons
    const abort_button = this.container.querySelector("#sc-abort-button");
    abort_button.addEventListener("click", () => {
      // abort current response
      this.env.chat_model.stop_stream();
      this.clear_streaming_ux();
    });
    const button = this.container.querySelector("#sc-send-button");
    button.addEventListener("click", (e) => {
      // get container with .sc-chat-form from target
      const chat_input = e.target.closest(".sc-chat-form");
      const textarea = chat_input.querySelector("textarea");
      this.handle_send();
      // refocus chat input
      textarea.focus();
    });
  }
  key_down_handler(e) {
    if (e.key === "Enter" &amp;&amp; e.shiftKey) {
      e.preventDefault();
      this.handle_send();
    }
  }
  key_up_handler(e) { }
  handle_send() {
    const chat_input = this.container.querySelector(".sc-chat-form");
    const textarea = chat_input.querySelector("textarea");
    if (this.prevent_input) {
      this.show_notice("Wait until current response is finished.");
      return;
    }
    // get text from textarea
    let user_input = textarea.value;
    // clear textarea
    textarea.value = "";
    // initiate response from assistant
    this.env.chats.current.new_user_message(user_input);
    textarea.style.height = 'auto';
    textarea.style.height = (textarea.scrollHeight) + 'px';
  }

  // render message
  async new_message(content, role = "assistant", append_last = false) {
    // if dotdotdot interval is set, then clear it
    if (this.dotdotdot_interval) {
      if(!this.last_msg) this.message_container.insertAdjacentHTML("beforeend", await this.get_message_html(role, content));
      clearInterval(this.dotdotdot_interval);
      this.dotdotdot_interval = null;
      this.last_msg_content.innerHTML = ''; // clear last message
      this.last_msg.dataset.content = "";
    }
    if(this.last_msg &amp;&amp; !this.last_msg.dataset.content) this.last_msg.dataset.content = "";
    if (append_last) {
      this.last_msg_content.innerHTML += content;
      this.last_msg.dataset.content += content;
      if (content.indexOf('\n') > -1) this.render_md_as_html(this.last_msg);
    } else {
      if (this.last_from !== role) {
        const html = await this.get_message_html(role, content);
        this.message_container.insertAdjacentHTML("beforeend", html); // append html to this.message_container while preserving other elements in this.message_container.
        this.last_from = role; // set last from
        this.last_msg.dataset.content = content;
      } else {
        this.last_msg_content.innerHTML = content;
        this.last_msg.dataset.content = content;
      }
      this.message_post_process(this.last_msg);
    }
    this.message_container.scrollTop = this.message_container.scrollHeight;
  }

  /**
   * Generates HTML for a message based on the role and content.
   * @param {string} role - The role of the message sender.
   * @param {string} content - The content of the message.
   * @returns {Promise&lt;string>} The HTML string for the message.
   */
  async get_message_html(role, content) {
    if(Array.isArray(content)) content = message_content_array_to_markdown(content);
    return await this.render(this.templates.smart_chat_msg, { role, content }, { context: this.view_context, rmWhitespace: true });
  }

  async get_system_message_html(msg) {
    let { content, role } = msg;
    if(content.includes('```sc-system')) {
      content = content.replace(/```sc-system|```/g, "").trim();
      content = "system prompts: " + content.split('\n').filter(ln => ln.trim()).join(', ');
    }
    if(content.includes('```sc-context')) {
      content = content.replace(/```sc-context|```/g, "").trim();
      content = "context: " + content.split('\n').filter(ln => ln.trim()).join(', ');
      if(content.length > 100) content = content.substring(0, 100) + "...";
    }
    return await this.render(this.templates.smart_chat_system_msg, { content, role }, { context: this.view_context, rmWhitespace: true });
  }

  /**
   * Inserts selected text from a suggestion modal into the chat input.
   * @param {string} insert_text - The text to insert.
   */
  insert_selection(insert_text) {
    const textarea = this.container.querySelector(".sc-chat-form textarea");
    let caret_pos = textarea.selectionStart;
    let text_before = textarea.value.substring(0, caret_pos);
    let text_after = textarea.value.substring(caret_pos, textarea.value.length);
    textarea.value = text_before + insert_text + text_after;
    textarea.selectionStart = caret_pos + insert_text.length;
    textarea.selectionEnd = caret_pos + insert_text.length;
    textarea.focus();
  }

  /**
   * Renders a typing indicator ("...") and sets an interval to animate it.
   */
  async render_dotdotdot() {
    if (this.dotdotdot_interval) clearInterval(this.dotdotdot_interval);
    await this.new_message("...", "assistant");
    let dots = 0;
    const curr_msg = this.last_msg_content;
    curr_msg.innerHTML = '...';
    this.dotdotdot_interval = setInterval(() => {
      dots++;
      if (dots > 3) dots = 1;
      curr_msg.innerHTML = '.'.repeat(dots);
    }, 500);
  }

  /**
   * Returns the message container element.
   * @returns {HTMLElement} The message container.
   */
  get message_container() { return this.container.querySelector(".sc-message-container"); }

  /**
   * Returns the last message content element.
   * @returns {HTMLElement} The last message content element.
   */
  get last_msg() { return this.container.querySelector(".sc-message-container").lastElementChild.querySelector(".sc-message-content"); }

  /**
   * Returns the last message content span element.
   * @returns {HTMLElement} The last message content span element.
   */
  get last_msg_content() { return this.last_msg.querySelector("span:not(.sc-msg-button)"); }

  /**
   * Returns all message content elements.
   * @returns {NodeListOf&lt;HTMLElement>} A NodeList of message content elements.
   */
  get messages() { return this.container.querySelectorAll(".sc-message-container .sc-message-content"); }

  /**
   * Sets the user interface to a "streaming" mode, disabling input and showing an abort button.
   */
  set_streaming_ux() {
    this.prevent_input = true;
    // hide send button
    if (this.container.querySelector("#sc-send-button"))
      this.container.querySelector("#sc-send-button").style.display = "none";
    // show abort button
    if (this.container.querySelector("#sc-abort-button"))
      this.container.querySelector("#sc-abort-button").style.display = "block";
  }

  /**
   * Resets the user interface from "streaming" mode to normal.
   */
  unset_streaming_ux() {
    this.prevent_input = false;
    // show send button, remove display none
    if (this.container.querySelector("#sc-send-button"))
      this.container.querySelector("#sc-send-button").style.display = "";
    // hide abort button
    if (this.container.querySelector("#sc-abort-button"))
      this.container.querySelector("#sc-abort-button").style.display = "none";
  }

  /**
   * Clears any streaming user interface effects, such as intervals and temporary elements.
   */
  clear_streaming_ux() {
    this.unset_streaming_ux();
    if (this.dotdotdot_interval) {
      clearInterval(this.dotdotdot_interval);
      this.dotdotdot_interval = null;
      if(['.', '..', '...'].includes(this.last_msg_content.innerHTML.trim())){
        this.last_msg.parentElement.remove();
      }
    }
  }

  /**
   * Update/set text in chat_input
   */
  set_chat_input_text(text){
    const textarea = this.container.querySelector(".sc-chat-form textarea");
    textarea.value = text;
  }

  undo_last_message(){
    if(this.dotdotdot_interval) this.clear_streaming_ux();
    this.last_msg.parentElement.remove();
    this.env.chats.current.remove_last_message();
  }
}
exports.SmartChatsUI = SmartChatsUI;

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AnthropicAdapter.html">AnthropicAdapter</a></li><li><a href="Book.html">Book</a></li><li><a href="CanvasAdapter.html">CanvasAdapter</a></li><li><a href="CohereAdapter.html">CohereAdapter</a></li><li><a href="Collection.html">Collection</a></li><li><a href="CollectionItem.html">CollectionItem</a></li><li><a href="GeminiAdapter.html">GeminiAdapter</a></li><li><a href="MarkdownAdapter.html">MarkdownAdapter</a></li><li><a href="MultiFileSmartCollectionsAdapter.html">MultiFileSmartCollectionsAdapter</a></li><li><a href="SmartChatAdapters.html">SmartChatAdapters</a></li><li><a href="SmartChatMD.html">SmartChatMD</a></li><li><a href="SmartChatModel.html">SmartChatModel</a></li><li><a href="SmartChats.html">SmartChats</a></li><li><a href="SmartChatsUI.html">SmartChatsUI</a></li><li><a href="SmartMarkdown.html">SmartMarkdown</a></li></ul><h3>Global</h3><ul><li><a href="global.html#add">add</a></li><li><a href="global.html#chat_ml_to_markdown">chat_ml_to_markdown</a></li><li><a href="global.html#chatml_to_anthropic">chatml_to_anthropic</a></li><li><a href="global.html#chatml_to_cohere">chatml_to_cohere</a></li><li><a href="global.html#chatml_to_gemini">chatml_to_gemini</a></li><li><a href="global.html#collection_instance_name_from">collection_instance_name_from</a></li><li><a href="global.html#cos_sim">cos_sim</a></li><li><a href="global.html#create_uid">create_uid</a></li><li><a href="global.html#deep_merge">deep_merge</a></li><li><a href="global.html#is_valid_tool_call">is_valid_tool_call</a></li><li><a href="global.html#markdown_to_chat_ml">markdown_to_chat_ml</a></li><li><a href="global.html#sequential_async_processor">sequential_async_processor</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#subtract">subtract</a></li><li><a href="global.html#top_acc">top_acc</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Wed Sep 11 2024 16:40:14 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
