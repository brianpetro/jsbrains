export const transformers_connector = "var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// ../smart-model/smart_model.js\nvar SmartModel = class {\n  /**\n   * Create a SmartModel instance.\n   * @param {Object} opts - Configuration options\n   * @param {Object} opts.adapters - Map of adapter names to adapter classes\n   * @param {Object} opts.settings - Model settings configuration\n   * @param {string} [opts.model_key] - Optional model identifier to override settings\n   * @throws {Error} If required options are missing\n   */\n  constructor(opts = {}) {\n    __publicField(this, \"scope_name\", \"smart_model\");\n    this.opts = opts;\n    this.validate_opts(opts);\n    this.state = \"unloaded\";\n    this._adapter = null;\n  }\n  /**\n   * Initialize the model by loading the configured adapter.\n   * @async\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    this.load_adapter(this.adapter_name);\n    await this.load();\n  }\n  /**\n   * Validate required options.\n   * @param {Object} opts - Configuration options\n   */\n  validate_opts(opts) {\n    if (!opts.adapters) throw new Error(\"opts.adapters is required\");\n    if (!opts.settings) throw new Error(\"opts.settings is required\");\n  }\n  /**\n   * Get the current settings\n   * @returns {Object} Current settings\n   */\n  get settings() {\n    if (!this.opts.settings) this.opts.settings = {\n      ...this.constructor.defaults\n    };\n    return this.opts.settings;\n  }\n  /**\n   * Get the current adapter name\n   * @returns {string} Current adapter name\n   */\n  get adapter_name() {\n    let adapter_key = this.opts.adapter || this.settings.adapter || Object.keys(this.adapters)[0];\n    if (!adapter_key || !this.adapters[adapter_key]) {\n      console.warn(`Platform \"${adapter_key}\" not supported`);\n      adapter_key = Object.keys(this.adapters)[0];\n    }\n    return adapter_key;\n  }\n  /**\n   * Get available models.\n   * @returns {Object} Map of model objects\n   */\n  get models() {\n    return this.adapter.models;\n  }\n  /**\n   * Get default model key.\n   * @returns {string} Default model key\n   */\n  get default_model_key() {\n    return this.adapter.constructor.defaults.default_model;\n  }\n  /**\n   * Get the current model key\n   * @returns {string} Current model key\n   */\n  get model_key() {\n    return this.opts.model_key || this.settings.model_key || this.default_model_key;\n  }\n  /**\n   * Load the current adapter and transition to loaded state.\n   * @async\n   * @returns {Promise<void>}\n   */\n  async load() {\n    this.set_state(\"loading\");\n    try {\n      if (!this.adapter?.is_loaded) {\n        await this.invoke_adapter_method(\"load\");\n      }\n    } catch (err) {\n      this.set_state(\"unloaded\");\n      if (!this.reload_model_timeout) {\n        this.reload_model_timeout = setTimeout(async () => {\n          this.reload_model_timeout = null;\n          await this.load();\n          this.set_state(\"loaded\");\n          this.env?.events?.emit(\"model:loaded\", { model_key: this.model_key });\n          this.notices?.show(\"Loaded model: \" + this.model_key);\n        }, 6e4);\n      }\n      throw new Error(`Failed to load model: ${err.message}`);\n    }\n    this.set_state(\"loaded\");\n  }\n  /**\n   * Unload the current adapter and transition to unloaded state.\n   * @async\n   * @returns {Promise<void>}\n   */\n  async unload() {\n    if (this.adapter?.is_loaded) {\n      this.set_state(\"unloading\");\n      await this.invoke_adapter_method(\"unload\");\n      this.set_state(\"unloaded\");\n    }\n  }\n  /**\n   * Set the model's state.\n   * @param {('unloaded'|'loading'|'loaded'|'unloading')} new_state - The new state\n   * @throws {Error} If the state is invalid\n   */\n  set_state(new_state) {\n    const valid_states = [\"unloaded\", \"loading\", \"loaded\", \"unloading\"];\n    if (!valid_states.includes(new_state)) {\n      throw new Error(`Invalid state: ${new_state}`);\n    }\n    this.state = new_state;\n  }\n  get is_loading() {\n    return this.state === \"loading\";\n  }\n  get is_loaded() {\n    return this.state === \"loaded\";\n  }\n  get is_unloading() {\n    return this.state === \"unloading\";\n  }\n  get is_unloaded() {\n    return this.state === \"unloaded\";\n  }\n  // ADAPTERS\n  /**\n   * Get the map of available adapters\n   * @returns {Object} Map of adapter names to adapter classes\n   */\n  get adapters() {\n    return this.opts.adapters || {};\n  }\n  /**\n   * Load a specific adapter by name.\n   * @async\n   * @param {string} adapter_name - Name of the adapter to load\n   * @throws {Error} If adapter not found or loading fails\n   * @returns {Promise<void>}\n   */\n  async load_adapter(adapter_name) {\n    this.set_adapter(adapter_name);\n    if (!this._adapter.loaded) {\n      this.set_state(\"loading\");\n      try {\n        await this.invoke_adapter_method(\"load\");\n        this.set_state(\"loaded\");\n      } catch (err) {\n        this.set_state(\"unloaded\");\n        throw new Error(`Failed to load adapter: ${err.message}`);\n      }\n    }\n  }\n  /**\n   * Set an adapter instance by name without loading it.\n   * @param {string} adapter_name - Name of the adapter to set\n   * @throws {Error} If adapter not found\n   */\n  set_adapter(adapter_name) {\n    const AdapterClass = this.adapters[adapter_name];\n    if (!AdapterClass) {\n      throw new Error(`Adapter \"${adapter_name}\" not found.`);\n    }\n    if (this._adapter?.constructor.name.toLowerCase() === adapter_name.toLowerCase()) {\n      return;\n    }\n    this._adapter = new AdapterClass(this);\n  }\n  /**\n   * Get the current active adapter instance\n   * @returns {Object} The active adapter instance\n   * @throws {Error} If adapter not found\n   */\n  get adapter() {\n    const adapter_name = this.adapter_name;\n    if (!adapter_name) {\n      throw new Error(`Adapter not set for model.`);\n    }\n    if (!this._adapter) {\n      this.load_adapter(adapter_name);\n    }\n    return this._adapter;\n  }\n  /**\n   * Ensure the adapter is ready to execute a method.\n   * @param {string} method - Name of the method to check\n   * @throws {Error} If adapter not loaded or method not implemented\n   */\n  ensure_adapter_ready(method) {\n    if (!this.adapter) {\n      throw new Error(\"No adapter loaded.\");\n    }\n    if (typeof this.adapter[method] !== \"function\") {\n      throw new Error(`Adapter does not implement method: ${method}`);\n    }\n  }\n  /**\n   * Invoke a method on the current adapter.\n   * @async\n   * @param {string} method - Name of the method to call\n   * @param {...any} args - Arguments to pass to the method\n   * @returns {Promise<any>} Result from the adapter method\n   * @throws {Error} If adapter not ready or method fails\n   */\n  async invoke_adapter_method(method, ...args) {\n    this.ensure_adapter_ready(method);\n    return await this.adapter[method](...args);\n  }\n  /**\n   * Get platforms as dropdown options.\n   * @returns {Array<Object>} Array of {value, name} option objects\n   */\n  get_platforms_as_options() {\n    return Object.entries(this.adapters).map(([key, AdapterClass]) => ({ value: key, name: AdapterClass.defaults.description || key }));\n  }\n  // SETTINGS\n  /**\n   * Get the settings configuration schema\n   * @returns {Object} Settings configuration object\n   */\n  get settings_config() {\n    return this.process_settings_config({\n      adapter: {\n        name: \"Model Platform\",\n        type: \"dropdown\",\n        description: \"Select a model platform to use with Smart Model.\",\n        options_callback: \"get_platforms_as_options\",\n        is_scope: true,\n        // trigger re-render of settings when changed\n        callback: \"adapter_changed\",\n        default: \"default\"\n      }\n    });\n  }\n  /**\n   * Process settings configuration with conditionals and prefixes.\n   * @param {Object} _settings_config - Raw settings configuration\n   * @param {string} [prefix] - Optional prefix for setting keys\n   * @returns {Object} Processed settings configuration\n   */\n  process_settings_config(_settings_config, prefix = null) {\n    return Object.entries(_settings_config).reduce((acc, [key, val]) => {\n      const new_key = (prefix ? prefix + \".\" : \"\") + this.process_setting_key(key);\n      acc[new_key] = val;\n      return acc;\n    }, {});\n  }\n  /**\n   * Process an individual setting key.\n   * Example: replace placeholders with actual adapter names.\n   * @param {string} key - The setting key with placeholders.\n   * @returns {string} Processed setting key.\n   */\n  process_setting_key(key) {\n    return key.replace(/\\[ADAPTER\\]/g, this.adapter_name);\n  }\n  re_render_settings() {\n    if (typeof this.opts.re_render_settings === \"function\") this.opts.re_render_settings();\n    else console.warn(\"re_render_settings is not a function (must be passed in model opts)\");\n  }\n  /**\n   * Reload model.\n   */\n  reload_model() {\n    if (typeof this.opts.reload_model === \"function\") this.opts.reload_model();\n    else console.warn(\"reload_model is not a function (must be passed in model opts)\");\n  }\n  adapter_changed() {\n    this.reload_model();\n    this.re_render_settings();\n  }\n  model_changed() {\n    this.reload_model();\n    this.re_render_settings();\n  }\n};\n__publicField(SmartModel, \"defaults\", {\n  // override in sub-class if needed\n});\n\n// smart_rank_model.js\nvar SmartRankModel = class extends SmartModel {\n  /**\n   * Load the SmartRankModel with the specified configuration.\n   * @param {Object} env - Environment configurations.\n   * @param {Object} opts - Configuration options.\n   * @param {string} opts.model_key - Model key to select the adapter.\n   * @param {Object} [opts.adapters] - Optional map of adapters to override defaults.\n   * @param {Object} [opts.settings] - Optional user settings.\n   * @returns {Promise<SmartRankModel>} Loaded SmartRankModel instance.\n   * \n   * @example\n   * ```javascript\n   * const rankModel = await SmartRankModel.load(env, {\n   *   model_key: 'cohere',\n   *   adapter: 'cohere',\n   *   settings: {\n   *     cohere_api_key: 'your-cohere-api-key',\n   *   },\n   * });\n   * ```\n   */\n  /**\n   * Rank documents based on a query.\n   * @param {string} query - The query string.\n   * @param {Array<string>} documents - Array of document strings to rank.\n   * @param {Object} [options={}] - Additional ranking options.\n   * @param {number} [options.top_k] - Limit the number of returned documents.\n   * @param {boolean} [options.return_documents=false] - Whether to include original documents in results.\n   * @returns {Promise<Array<Object>>} Ranked documents with properties like {index, score, text}.\n   * \n   * @example\n   * ```javascript\n   * const rankings = await rankModel.rank(\"What is the capital of the United States?\", [\n   *   \"Carson City is the capital city of the American state of Nevada.\",\n   *   \"The Commonwealth of the Northern Mariana Islands is a group of islands in the Pacific Ocean. Its capital is Saipan.\",\n   *   \"Washington, D.C. is the capital of the United States.\",\n   * ]);\n   * console.log(rankings);\n   * ```\n   */\n  async rank(query, documents, options = {}) {\n    return await this.invoke_adapter_method(\"rank\", query, documents, options);\n  }\n  /**\n   * Get the default model key.\n   * @returns {string} Default model key.\n   */\n  get default_model_key() {\n    return \"jinaai/jina-reranker-v1-tiny-en\";\n  }\n  /**\n   * Get settings configuration schema.\n   * @returns {Object} Settings configuration object.\n   */\n  get settings_config() {\n    const _settings_config = {\n      adapter: {\n        name: \"Ranking Model Platform\",\n        type: \"dropdown\",\n        description: \"Select a ranking model platform.\",\n        options_callback: \"get_platforms_as_options\",\n        callback: \"adapter_changed\",\n        default: this.constructor.defaults.adapter\n      },\n      // Add adapter-specific settings here\n      ...this.adapter.settings_config || {}\n    };\n    return this.process_settings_config(_settings_config);\n  }\n};\n/**\n * Default configurations for SmartRankModel.\n * @type {Object}\n */\n__publicField(SmartRankModel, \"defaults\", {\n  adapter: \"cohere\",\n  model_key: \"rerank-v3.5\"\n  // LOCAL RERANKER CURRENTLY TOO SLOW FOR DEFAULT\n  // adapter: 'transformers', // Default to transformers adapter\n  // model_key: 'jinaai/jina-reranker-v1-tiny-en',\n});\n\n// ../smart-model/adapters/_adapter.js\nvar SmartModelAdapter = class {\n  /**\n   * Create a SmartModelAdapter instance.\n   * @param {SmartModel} model - The parent SmartModel instance\n   */\n  constructor(model2) {\n    this.model = model2;\n    this.state = \"unloaded\";\n  }\n  /**\n   * Load the adapter.\n   * @async\n   * @returns {Promise<void>}\n   */\n  async load() {\n    this.set_state(\"loaded\");\n  }\n  /**\n   * Unload the adapter.\n   * @returns {void}\n   */\n  unload() {\n    this.set_state(\"unloaded\");\n  }\n  /**\n   * Get all settings.\n   * @returns {Object} All settings\n   */\n  get settings() {\n    return this.model.settings;\n  }\n  /**\n   * Get the current model key.\n   * @returns {string} Current model identifier\n   */\n  get model_key() {\n    return this.model.model_key;\n  }\n  /**\n   * Get the models.\n   * @returns {Object} Map of model objects\n   */\n  get models() {\n    const models = this.model.data.provider_models;\n    if (typeof models === \"object\" && Object.keys(models || {}).length > 0) return models;\n    else {\n      return {};\n    }\n  }\n  /**\n   * Get available models from the API.\n   * @abstract\n   * @param {boolean} [refresh=false] - Whether to refresh cached models\n   * @returns {Promise<Object>} Map of model objects\n   */\n  async get_models(refresh = false) {\n    throw new Error(\"get_models not implemented\");\n  }\n  /**\n   * Get available models as dropdown options synchronously.\n   * @returns {Array<Object>} Array of model options.\n   */\n  get_models_as_options() {\n    const models = this.models;\n    if (!Object.keys(models || {}).length) {\n      this.get_models(true);\n      return [{ value: \"\", name: \"No models currently available\" }];\n    }\n    return Object.entries(models).map(([id, model2]) => ({ value: id, name: model2.name || id })).sort((a, b) => a.name.localeCompare(b.name));\n  }\n  /**\n   * Set the adapter's state.\n   * @deprecated should be handled in SmartModel (only handle once)\n   * @param {('unloaded'|'loading'|'loaded'|'unloading')} new_state - The new state\n   * @throws {Error} If the state is invalid\n   */\n  set_state(new_state) {\n    const valid_states = [\"unloaded\", \"loading\", \"loaded\", \"unloading\"];\n    if (!valid_states.includes(new_state)) {\n      throw new Error(`Invalid state: ${new_state}`);\n    }\n    this.state = new_state;\n  }\n  // Replace individual state getters/setters with a unified state management\n  get is_loading() {\n    return this.state === \"loading\";\n  }\n  get is_loaded() {\n    return this.state === \"loaded\";\n  }\n  get is_unloading() {\n    return this.state === \"unloading\";\n  }\n  get is_unloaded() {\n    return this.state === \"unloaded\";\n  }\n};\n\n// adapters/_adapter.js\nvar settings_config = {\n  \"[ADAPTER].model_key\": {\n    name: \"Ranking Model\",\n    type: \"dropdown\",\n    description: \"Select a ranking model to use.\",\n    options_callback: \"adapter.get_models_as_options\",\n    callback: \"reload_model\"\n  }\n};\nvar SmartRankAdapter = class extends SmartModelAdapter {\n  /**\n   * Create a SmartRankAdapter instance.\n   * @param {SmartRankModel} model - The parent SmartRankModel instance\n   */\n  constructor(model2) {\n    super(model2);\n    this.smart_rank = model2;\n  }\n  /**\n   * Rank documents based on a query.\n   * @abstract\n   * @param {string} query - The query string\n   * @param {Array<string>} documents - The documents to rank\n   * @returns {Promise<Array<Object>>} Array of ranking results {index, score, ...}\n   * @throws {Error} If the method is not implemented by subclass\n   */\n  async rank(query, documents) {\n    throw new Error(\"rank method not implemented\");\n  }\n  get settings_config() {\n    return settings_config;\n  }\n};\n\n// adapters/transformers.js\nvar transformers_defaults = {\n  adapter: \"transformers\",\n  description: \"Transformers\",\n  default_model: \"jinaai/jina-reranker-v1-tiny-en\"\n};\nvar transformers_models = {\n  \"jinaai/jina-reranker-v1-tiny-en\": {\n    id: \"jinaai/jina-reranker-v1-tiny-en\",\n    adapter: \"transformers\",\n    model_key: \"jinaai/jina-reranker-v1-tiny-en\"\n  },\n  \"jinaai/jina-reranker-v1-turbo-en\": {\n    id: \"jinaai/jina-reranker-v1-turbo-en\",\n    adapter: \"transformers\",\n    model_key: \"jinaai/jina-reranker-v1-turbo-en\"\n  },\n  \"mixedbread-ai/mxbai-rerank-xsmall-v1\": {\n    id: \"mixedbread-ai/mxbai-rerank-xsmall-v1\",\n    adapter: \"transformers\",\n    model_key: \"mixedbread-ai/mxbai-rerank-xsmall-v1\"\n  },\n  \"Xenova/bge-reranker-base\": {\n    id: \"Xenova/bge-reranker-base\",\n    adapter: \"transformers\",\n    model_key: \"Xenova/bge-reranker-base\"\n  }\n};\nvar transformers_settings_config = {\n  use_gpu: {\n    setting: \"use_gpu\",\n    name: \"Use GPU\",\n    description: \"Use GPU for ranking (faster, may not work on all systems)\",\n    type: \"toggle\",\n    default: true\n  }\n};\nvar SmartRankTransformersAdapter = class extends SmartRankAdapter {\n  /**\n   * Create transformers adapter instance\n   * @param {SmartRankModel} model - Parent model instance\n   */\n  constructor(model2) {\n    super(model2);\n    this.model_instance = null;\n    this.tokenizer = null;\n  }\n  /**\n   * Load model and tokenizer\n   * @async\n   * @returns {Promise<void>}\n   */\n  async load() {\n    console.log(\"TransformersAdapter initializing\");\n    console.log(this.model.model_key);\n    const { AutoTokenizer, AutoModelForSequenceClassification, env } = await import(\"https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.8.0\");\n    env.allowLocalModels = false;\n    const pipeline_opts = {\n      quantized: true\n    };\n    if (this.model.opts.use_gpu) {\n      console.log(\"[Transformers] Using GPU\");\n      pipeline_opts.device = \"webgpu\";\n    } else {\n      console.log(\"[Transformers] Using CPU\");\n    }\n    this.tokenizer = await AutoTokenizer.from_pretrained(this.model.model_key);\n    this.model_instance = await AutoModelForSequenceClassification.from_pretrained(this.model.model_key, pipeline_opts);\n    console.log(\"TransformersAdapter initialized\", this.model.model_key);\n    this.model.model_loaded = true;\n    this.set_state(\"loaded\");\n  }\n  /**\n   * Rank documents based on a query\n   * @param {string} query - The query string\n   * @param {Array<string>} documents - Documents to rank\n   * @param {Object} [options={}] - Additional ranking options\n   * @param {number} [options.top_k] - Limit the number of returned documents\n   * @param {boolean} [options.return_documents=false] - Whether to include original documents in results\n   * @returns {Promise<Array<Object>>} Ranked documents: [{index, score, text?}, ...]\n   */\n  async rank(query, documents, options = {}) {\n    console.log(\"TransformersAdapter ranking\");\n    if (!this.model_instance || !this.tokenizer) {\n      await this.load();\n    }\n    const { top_k = void 0, return_documents = false } = options;\n    console.log(\"tokenizing\", query, documents);\n    const inputs = this.tokenizer(\n      new Array(documents.length).fill(query),\n      { text_pair: documents, padding: true, truncation: true }\n    );\n    console.log(\"inputs\", inputs);\n    const { logits } = await this.model_instance(inputs);\n    console.log(\"done\", logits);\n    console.log(\"logits.data\", logits.data);\n    const results = logits.sigmoid().tolist().map(([score], i) => ({\n      index: i,\n      score,\n      ...return_documents ? { text: documents[i] } : {}\n    })).sort((a, b) => b.score - a.score).slice(0, top_k);\n    console.log(results);\n    return results;\n  }\n  get models() {\n    return transformers_models;\n  }\n  get settings_config() {\n    return {\n      ...super.settings_config || {},\n      ...transformers_settings_config\n    };\n  }\n};\n__publicField(SmartRankTransformersAdapter, \"defaults\", transformers_defaults);\n\n// build/transformers_iframe_script.js\nvar model = null;\nasync function process_message(data) {\n  const { method, params, id, iframe_id } = data;\n  try {\n    let result;\n    switch (method) {\n      case \"init\":\n        console.log(\"init\");\n        break;\n      case \"load\":\n        console.log(\"load\", params);\n        model = new SmartRankModel({\n          ...params,\n          adapters: { transformers: SmartRankTransformersAdapter },\n          adapter: \"transformers\",\n          settings: {}\n        });\n        await model.load();\n        result = { model_loaded: true };\n        break;\n      case \"rank\":\n        if (!model) throw new Error(\"Model not loaded\");\n        result = await model.rank(params.query, params.documents);\n        break;\n      default:\n        throw new Error(`Unknown method: ${method}`);\n    }\n    return { id, result, iframe_id };\n  } catch (error) {\n    console.error(\"Error processing message:\", error);\n    return { id, error: error.message, iframe_id };\n  }\n}\nprocess_message({ method: \"init\" });\n";