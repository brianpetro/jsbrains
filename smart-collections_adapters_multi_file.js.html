<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: smart-collections/adapters/multi_file.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: smart-collections/adapters/multi_file.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { ajson_merge } from '../utils/ajson_merge.js';
import { SmartCollectionDataAdapter } from './_adapter.js';


// DO: replace this better way in future
const class_to_collection_name = {
  'SmartSource': 'smart_sources',
  'SmartBlock': 'smart_blocks',
  'SmartDirectory': 'smart_directories',
};
export class MultiFileSmartCollectionDataAdapter extends SmartCollectionDataAdapter {
  get fs() { return this.env.smart_env_settings.fs; }
  /**
   * @returns {string} The data folder that contains .ajson files.
   */
  get data_folder() { return 'multi'; }
  /**
   * @returns {string} The data path for .ajson file.
   */
  get data_path() { return this.data_folder + this.fs.sep + this.item.multi_ajson_file_name + '.ajson'; }

  /**
   * Asynchronously loads collection item data from .ajson file specified by data_path.
   */
  async load() {
    const exists = await this.fs.exists(this.data_path);
    const data_ajson = exists ? (await this.fs.read(this.data_path)).trim() : '';
    if(!exists || !data_ajson) return await this.item.queue_import(); // queue import and return early if data file missing or empty
    const parsed_data = data_ajson
      .split('\n')
      .reduce((acc, line) => {
        const parsed = JSON.parse(`{${line}}`);
        if(Object.values(parsed)[0] === null){
          if(acc[Object.keys(parsed)[0]]) delete acc[Object.keys(parsed)[0]];
          return acc;
        }
        return ajson_merge(acc, parsed);
      }, {})
    ;
    Object.entries(parsed_data)
      .forEach(([ajson_key, value]) => {
        if(!value) return; // handle null values (deleted)
        const [class_name, ...key_parts] = ajson_key.split(":");
        const entity_key = key_parts.join(":"); // key is file path
        if(entity_key === this.key) this.item.data = value;
        else {
          if(!this.env[class_to_collection_name[class_name]]) return console.warn(`Collection class not found: ${class_name}`);
          this.env[class_to_collection_name[class_name]].items[entity_key] = new this.env.item_types[class_name](this.env, value);
        }
      })
    ;
    this.item._queue_load = false;
    if(data_ajson !== this.item.ajson) await this.fs.write(this.data_path, this.item.ajson);
  }

  async save() {
    if(!(await this.fs.exists(this.data_folder))) await this.fs.mkdir(this.data_folder);
    try {
      if(this.item.deleted){
        this.collection.delete_item(this.key);
        if((await this.fs.exists(this.data_path))) await this.fs.remove(this.data_path);
      } else {
        // await this.fs.write(this.data_path, this.item.ajson);
        await this.fs.append(this.data_path, '\n' + this.item.ajson); // prevent overwriting the file
        // console.log("Saved item: ", this.item.key, this.data_path);
      }
      this.item._queue_save = false;
      return true;
    } catch (err) {
      if(err.message.includes("ENOENT")) return; // already deleted
      console.warn("Error saving collection item: ", this.key);
      console.warn(err.stack);
      this.item.queue_save();
      return false;
    }
  }
}


/**
 * @deprecated use MultiFileSmartCollectionDataAdapter
 */
export class MultiFileSmartCollectionsAdapter {

  // get fs() { return this.collection.env.smart_env_settings.fs; }
  // /**
  //  * @returns {string} The data path for folder that contains .ajson files.
  //  */
  // // get data_path() { return this.collection.data_path + '/multi'; }
  // // get data_path() { return this.env.settings.env_data_dir + this.fs.sep + 'multi'; }
  // get data_path() { return 'multi'; }

  // /**
  //  * Asynchronously loads collection items from .ajson files within the specified data path.
  //  * It ensures that only .ajson files are processed and handles JSON parsing and item instantiation.
  //  */
  // async load() {
  //   console.log("Loading collection items");
  //   const start = Date.now();
  //   if(!(await this.fs.exists(this.data_path))) await this.fs.mkdir(this.data_path);
  //   const collection_data_files = (await this.fs.list_files(this.data_path)); // List all files in the directory
  //   const vault_paths = this.collection.fs.files; // initiated in SmartFs.init()
  //   const item_types = [
  //     ...Object.keys(this.env.item_types),
  //     'SmartNote', // v1 backward compatibility
  //   ];
  //   for (const collection_item_data_file of collection_data_files) {
  //     const item_data_file_path = collection_item_data_file.path;
  //     if(!item_data_file_path.endsWith('.ajson')) continue; // ensure it's an .ajson file
  //     let source_is_deleted = false;
  //     try {
  //       const content = (await this.fs.read(item_data_file_path)).trim();
  //       const data = content
  //         .split('\n')
  //         .reduce((acc, line) => {
  //           const parsed = JSON.parse(`{${line}}`);
  //           if(Object.values(parsed)[0] === null){
  //             if(acc[Object.keys(parsed)[0]]) delete acc[Object.keys(parsed)[0]];
  //             return acc;
  //           }
  //           return ajson_merge(acc, parsed);
  //         }, {})
  //       ;
  //       let main_entity;
  //       let main_entity_key;
  //       Object.entries(data)
  //         .forEach(([ajson_key, value]) => {
  //           if(!value || source_is_deleted) return; // handle null values (deleted)
  //           let entity_key;
  //           let class_name = value.class_name; // DEPRECATED (moved to key so that multiple entities from different classes can have the same key)
  //           if(ajson_key.includes(":") &amp;&amp; item_types.includes(ajson_key.split(":")[0])){
  //             class_name = ajson_key.split(":").shift();
  //             entity_key = ajson_key.split(":").slice(1).join(":"); // key is file path
  //           }else entity_key = ajson_key; // DEPRECATED: remove this
  //           if(!main_entity_key) main_entity_key = entity_key.includes("#") ? entity_key.split("#")[0] : entity_key;
  //           if(!vault_paths[main_entity_key]){ // if not in vault path, it's a deleted item
  //             source_is_deleted = true;
  //             return;
  //           }
  //           if(value.class_name === 'SmartNote') value.class_name = "SmartSource"; // v1 backward compatibility (depended on by CollectionItem.collection_name)
  //           if(class_name === 'SmartNote') class_name = 'SmartSource'; // v1 backward compatibility
  //           const entity = new (this.env.item_types[class_name])(this.env, value);
  //           this.add_to_collection(entity);
  //           if(!entity_key.includes("#")) main_entity = entity;
  //         })
  //       ;
  //       if(source_is_deleted || !main_entity){
  //         await this.fs.remove(item_data_file_path);
  //       }else if(main_entity.ajson !== content) {
  //         await this.fs.write(item_data_file_path, main_entity.ajson);
  //       }
  //     } catch (err) {
  //       console.log("Error loading file: " + item_data_file_path);
  //       console.log(err.stack); // stack trace
  //       // if parse error, remove file
  //       console.log(err.message);
  //       if(err.message.includes("Expected ")) await this.fs.remove(item_data_file_path);
  //     }
  //   }
  //   const end = Date.now(); // log time
  //   const time = end - start;
  //   console.log("Loaded collection items in " + time + "ms");
  // }

  // async save_item(key) {
  //   delete this.collection.save_queue[key];
  //   const item = this.collection.get(key);
  //   if(!item) return console.warn(`Item not found: ${key}, aborting save`);
  //   if(!(await this.fs.exists(this.data_path))) await this.fs.mkdir(this.data_path);
  //   try {
  //     const item_file_path = `${this.data_path}/${item.multi_ajson_file_name}.ajson`; // Use item.file_name for file naming
  //     if(item.deleted){
  //       // delete this.collection.items[key];
  //       this.collection.delete_item(key);
  //       if((await this.fs.exists(item_file_path))){
  //         await this.fs.remove(item_file_path);
  //         console.log("Deleted entity: " + key);
  //       }
  //     } else {
  //       const ajson = item.ajson;
  //       await this.fs.append(item_file_path, '\n' + ajson);
  //     }
  //   } catch (err) {
  //     if(err.message.includes("ENOENT")) return; // already deleted
  //     console.warn("Error saving collection item: ", key);
  //     console.warn(err.stack);
  //     item.queue_save();
  //   }
  // }

  // // override save_queue to log time
  // async save_queue() {
  //   console.log("Saving " + this.collection.collection_name);
  //   const queue_length = Object.keys(this._save_queue).length;
  //   const start = Date.now();
  //   await super.save_queue();
  //   console.log(`Saved ${queue_length} ${this.collection.collection_name} in ${Date.now() - start}ms`);
  // }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AnthropicAdapter.html">AnthropicAdapter</a></li><li><a href="Book.html">Book</a></li><li><a href="CanvasAdapter.html">CanvasAdapter</a></li><li><a href="CohereAdapter.html">CohereAdapter</a></li><li><a href="Collection.html">Collection</a></li><li><a href="CollectionItem.html">CollectionItem</a></li><li><a href="GeminiAdapter.html">GeminiAdapter</a></li><li><a href="MarkdownAdapter.html">MarkdownAdapter</a></li><li><a href="MultiFileSmartCollectionsAdapter.html">MultiFileSmartCollectionsAdapter</a></li><li><a href="SmartChatAdapters.html">SmartChatAdapters</a></li><li><a href="SmartChatMD.html">SmartChatMD</a></li><li><a href="SmartChatModel.html">SmartChatModel</a></li><li><a href="SmartChats.html">SmartChats</a></li><li><a href="SmartChatsUI.html">SmartChatsUI</a></li><li><a href="SmartMarkdown.html">SmartMarkdown</a></li></ul><h3>Global</h3><ul><li><a href="global.html#add">add</a></li><li><a href="global.html#chat_ml_to_markdown">chat_ml_to_markdown</a></li><li><a href="global.html#chatml_to_anthropic">chatml_to_anthropic</a></li><li><a href="global.html#chatml_to_cohere">chatml_to_cohere</a></li><li><a href="global.html#chatml_to_gemini">chatml_to_gemini</a></li><li><a href="global.html#collection_instance_name_from">collection_instance_name_from</a></li><li><a href="global.html#cos_sim">cos_sim</a></li><li><a href="global.html#create_uid">create_uid</a></li><li><a href="global.html#deep_merge">deep_merge</a></li><li><a href="global.html#is_valid_tool_call">is_valid_tool_call</a></li><li><a href="global.html#markdown_to_chat_ml">markdown_to_chat_ml</a></li><li><a href="global.html#sequential_async_processor">sequential_async_processor</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#subtract">subtract</a></li><li><a href="global.html#top_acc">top_acc</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Thu Aug 29 2024 22:59:07 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
