<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: smart-collections/adapters/multi_file.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: smart-collections/adapters/multi_file.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { ajson_merge } from '../utils/ajson_merge.js';
import { SmartCollectionAdapter } from './_adapter.js';
export class MultiFileSmartCollectionsAdapter extends SmartCollectionAdapter {

  get fs() { return this.collection.fs; }
  /**
   * @returns {string} The data path for folder that contains .ajson files.
   */
  get data_path() { return this.collection.data_path + '/multi'; }

  /**
   * Asynchronously loads collection items from .ajson files within the specified data path.
   * It ensures that only .ajson files are processed and handles JSON parsing and item instantiation.
   */
  async load() {
    console.log("Loading collection items");
    const start = Date.now();
    if(!(await this.fs.smart_env_data.exists(this.data_path))) await this.fs.smart_env_data.mkdir(this.data_path);
    const collection_data_files = (await this.fs.smart_env_data.list(this.data_path)); // List all files in the directory
    const vault_paths = (await this.fs.list_files_recursive('/')).reduce((acc, file) => {
      acc[file.path] = true;
      return acc;
    }, {});
    const item_types = [
      ...Object.keys(this.env.item_types),
      'SmartNote', // v1 backward compatibility
    ];
    for (const collection_item_data_file of collection_data_files) {
      const item_data_file_path = collection_item_data_file.path;
      if(!item_data_file_path.endsWith('.ajson')) continue; // ensure it's an .ajson file
      let source_is_deleted = false;
      try {
        const content = (await this.fs.smart_env_data.read(item_data_file_path)).trim();
        const data = content
          .split('\n')
          .reduce((acc, line) => {
            const parsed = JSON.parse(`{${line}}`);
            if(Object.values(parsed)[0] === null){
              if(acc[Object.keys(parsed)[0]]) delete acc[Object.keys(parsed)[0]];
              return acc;
            }
            return ajson_merge(acc, parsed);
          }, {})
        ;
        let main_entity;
        Object.entries(data)
          .forEach(([ajson_key, value]) => {
            if(!value || source_is_deleted) return; // handle null values (deleted)
            let entity_key;
            let class_name = value.class_name; // DEPRECATED (moved to key so that multiple entities from different classes can have the same key)
            if(ajson_key.includes(":") &amp;&amp; item_types.includes(ajson_key.split(":")[0])){
              class_name = ajson_key.split(":").shift();
              entity_key = ajson_key.split(":").slice(1).join(":"); // key is file path
            }else entity_key = ajson_key; // DEPRECATED: remove this
            const check_path = entity_key.includes("#") ? entity_key.split("#")[0] : entity_key;
            if(!vault_paths[check_path]){ // if not in vault path, it's a deleted item
              source_is_deleted = true;
              return;
            }
            if(value.class_name === 'SmartNote') value.class_name = "SmartSource"; // v1 backward compatibility (depended on by CollectionItem.collection_name)
            if(class_name === 'SmartNote') class_name = 'SmartSource'; // v1 backward compatibility
            const entity = new (this.env.item_types[class_name])(this.env, value);
            this.add_to_collection(entity);
            if(!entity_key.includes("#")) main_entity = entity;
          })
        ;
        if(source_is_deleted || !main_entity) await this.fs.smart_env_data.remove(item_data_file_path);
        else if(main_entity.ajson !== content) {
          await this.fs.smart_env_data.write(item_data_file_path, main_entity.ajson);
        }
      } catch (err) {
        console.log("Error loading file: " + item_data_file_path);
        console.log(err.stack); // stack trace
        // if parse error, remove file
        console.log(err.message);
        if(err.message.includes("Expected ")) await this.fs.smart_env_data.remove(item_data_file_path);
      }
    }
    const end = Date.now(); // log time
    const time = end - start;
    console.log("Loaded collection items in " + time + "ms");
  }

  async save_item(key) {
    delete this.collection.save_queue[key];
    const item = this.collection.get(key);
    if(!item) return console.warn(`Item not found: ${key}, aborting save`);
    if(!(await this.fs.smart_env_data.exists(this.data_path))) await this.fs.smart_env_data.mkdir(this.data_path);
    try {
      const item_file_path = `${this.data_path}/${item.multi_ajson_file_name}.ajson`; // Use item.file_name for file naming
      if(item.deleted){
        // delete this.collection.items[key];
        this.collection.delete_item(key);
        if((await this.fs.smart_env_data.exists(item_file_path))){
          await this.fs.smart_env_data.remove(item_file_path);
          console.log("Deleted entity: " + key);
        }
      } else {
        const ajson = item.ajson;
        await this.fs.smart_env_data.append(item_file_path, '\n' + ajson);
      }
    } catch (err) {
      if(err.message.includes("ENOENT")) return; // already deleted
      console.warn("Error saving collection item: ", key);
      console.warn(err.stack);
      item.queue_save();
    }
  }

  // override save_queue to log time
  async save_queue() {
    console.log("Saving " + this.collection.collection_name);
    const queue_length = Object.keys(this._save_queue).length;
    const start = Date.now();
    await super.save_queue();
    console.log(`Saved ${queue_length} ${this.collection.collection_name} in ${Date.now() - start}ms`);
  }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AnthropicAdapter.html">AnthropicAdapter</a></li><li><a href="Book.html">Book</a></li><li><a href="CanvasAdapter.html">CanvasAdapter</a></li><li><a href="CohereAdapter.html">CohereAdapter</a></li><li><a href="Collection.html">Collection</a></li><li><a href="CollectionItem.html">CollectionItem</a></li><li><a href="GeminiAdapter.html">GeminiAdapter</a></li><li><a href="MarkdownAdapter.html">MarkdownAdapter</a></li><li><a href="SmartChatAdapters.html">SmartChatAdapters</a></li><li><a href="SmartChatMD.html">SmartChatMD</a></li><li><a href="SmartChatModel.html">SmartChatModel</a></li><li><a href="SmartChats.html">SmartChats</a></li><li><a href="SmartChatsUI.html">SmartChatsUI</a></li><li><a href="SmartMarkdown.html">SmartMarkdown</a></li></ul><h3>Global</h3><ul><li><a href="global.html#add">add</a></li><li><a href="global.html#chat_ml_to_markdown">chat_ml_to_markdown</a></li><li><a href="global.html#chatml_to_anthropic">chatml_to_anthropic</a></li><li><a href="global.html#chatml_to_cohere">chatml_to_cohere</a></li><li><a href="global.html#chatml_to_gemini">chatml_to_gemini</a></li><li><a href="global.html#collection_instance_name_from">collection_instance_name_from</a></li><li><a href="global.html#cos_sim">cos_sim</a></li><li><a href="global.html#create_uid">create_uid</a></li><li><a href="global.html#deep_merge">deep_merge</a></li><li><a href="global.html#is_valid_tool_call">is_valid_tool_call</a></li><li><a href="global.html#markdown_to_chat_ml">markdown_to_chat_ml</a></li><li><a href="global.html#sequential_async_processor">sequential_async_processor</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#subtract">subtract</a></li><li><a href="global.html#top_acc">top_acc</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Mon Aug 19 2024 21:05:03 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
