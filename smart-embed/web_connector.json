{
  "script": "var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// models.json\nvar require_models = __commonJS({\n  \"models.json\"(exports, module2) {\n    module2.exports = {\n      \"TaylorAI/bge-micro-v2\": {\n        model_name: \"TaylorAI/bge-micro-v2\",\n        batch_size: 1,\n        dims: 384,\n        max_tokens: 512,\n        name: \"BGE-micro-v2\",\n        description: \"Local, 512 tokens, 384 dim\",\n        type: \"huggingface-transformers\"\n      },\n      \"andersonbcdefg/bge-small-4096\": {\n        model_name: \"andersonbcdefg/bge-small-4096\",\n        batch_size: 1,\n        dims: 384,\n        max_tokens: 4096,\n        name: \"BGE-small-4K\",\n        description: \"Local, 4,096 tokens, 384 dim\",\n        type: \"huggingface-transformers\"\n      },\n      \"Xenova/jina-embeddings-v2-base-zh-8192\": {\n        model_name: \"Xenova/jina-embeddings-v2-base-zh\",\n        batch_size: 1,\n        dims: 512,\n        max_tokens: 8192,\n        name: \"Jina-v2-base-zh-8K\",\n        description: \"Local, 8,192 tokens, 512 dim, Chinese/English bilingual\",\n        type: \"huggingface-transformers\"\n      },\n      \"text-embedding-3-small\": {\n        model_name: \"text-embedding-3-small\",\n        batch_size: 50,\n        dims: 1536,\n        max_tokens: 8191,\n        name: \"OpenAI Text-3 Small\",\n        description: \"API, 8,191 tokens, 1,536 dim\",\n        type: \"openai\"\n      },\n      \"text-embedding-3-large\": {\n        model_name: \"text-embedding-3-large\",\n        batch_size: 50,\n        dims: 3072,\n        max_tokens: 8191,\n        name: \"OpenAI Text-3 Large\",\n        description: \"API, 8,191 tokens, 3,072 dim\",\n        type: \"openai\"\n      },\n      \"text-embedding-3-small-512\": {\n        model_name: \"text-embedding-3-small\",\n        batch_size: 50,\n        dims: 512,\n        max_tokens: 8191,\n        name: \"OpenAI Text-3 Small - 512\",\n        description: \"API, 8,191 tokens, 512 dim\",\n        type: \"openai\"\n      },\n      \"text-embedding-3-large-256\": {\n        model_name: \"text-embedding-3-large\",\n        batch_size: 50,\n        dims: 256,\n        max_tokens: 8191,\n        name: \"OpenAI Text-3 Large - 256\",\n        description: \"API, 8,191 tokens, 256 dim\",\n        type: \"openai\"\n      },\n      \"text-embedding-ada-002\": {\n        model_name: \"text-embedding-ada-002\",\n        batch_size: 50,\n        dims: 1536,\n        max_tokens: 8191,\n        name: \"OpenAI Ada\",\n        description: \"API, 8,191 tokens, 1,536 dim\",\n        type: \"openai\"\n      },\n      \"Xenova/jina-embeddings-v2-small-en\": {\n        model_name: \"Xenova/jina-embeddings-v2-small-en\",\n        batch_size: 1,\n        dims: 512,\n        max_tokens: 8192,\n        name: \"Jina-v2-small-en\",\n        description: \"Local, 8,192 tokens, 512 dim\",\n        type: \"huggingface-transformers\"\n      },\n      \"nomic-ai/nomic-embed-text-v1.5-256\": {\n        model_name: \"nomic-ai/nomic-embed-text-v1.5\",\n        batch_size: 1,\n        dims: 256,\n        max_tokens: 8192,\n        name: \"Nomic-embed-text-v1.5\",\n        description: \"Local, 8,192 tokens, 256 dim\",\n        type: \"huggingface-transformers\"\n      },\n      \"Xenova/bge-small-en-v1.5\": {\n        model_name: \"Xenova/bge-small-en-v1.5\",\n        batch_size: 1,\n        dims: 384,\n        max_tokens: 512,\n        name: \"BGE-small\",\n        description: \"Local, 512 tokens, 384 dim\",\n        type: \"huggingface-transformers\"\n      },\n      \"nomic-ai/nomic-embed-text-v1\": {\n        model_name: \"nomic-ai/nomic-embed-text-v1\",\n        batch_size: 1,\n        dims: 768,\n        max_tokens: 2048,\n        name: \"Nomic-embed-text\",\n        description: \"Local, 2,048 tokens, 768 dim\",\n        type: \"huggingface-transformers\"\n      }\n    };\n  }\n});\n\n// SmartEmbed.js\nvar require_SmartEmbed = __commonJS({\n  \"SmartEmbed.js\"(exports) {\n    var models = require_models();\n    var SmartEmbed = class {\n      constructor(model) {\n        if (typeof model === \"object\") {\n          this.config = { ...model };\n        } else {\n          this.model_config_key = model;\n          this.config = models[this.model_config_key];\n        }\n        this.embed_ct = 0;\n        this.timestamp = null;\n        this.tokens = 0;\n      }\n      static async create(model_config_key, ...args) {\n        const adapter = new this(model_config_key, ...args);\n        await adapter.init();\n        return adapter;\n      }\n      async init() {\n      }\n      /**\n       * @param {string} input\n       * @returns {Promise<number>}\n       */\n      async count_tokens(input) {\n      }\n      /**\n       * @param {string} input\n       * @returns {Promise<number[]>}\n       */\n      async embed(input) {\n      }\n      /**\n       * @param {string[]} input\n       * @returns {Promise<number[][]>}\n       */\n      async embed_batch(input) {\n      }\n      get batch_size() {\n        return this.config.batch_size;\n      }\n      get dims() {\n        return this.config.dims;\n      }\n      get max_tokens() {\n        return this.config.max_tokens;\n      }\n      get model_name() {\n        return this.config.model_name;\n      }\n    };\n    exports.SmartEmbed = SmartEmbed;\n  }\n});\n\n// SmartEmbedTransformersNodeAdapter.js\nvar require_SmartEmbedTransformersNodeAdapter = __commonJS({\n  \"SmartEmbedTransformersNodeAdapter.js\"(exports) {\n    var { SmartEmbed } = require_SmartEmbed();\n    var SmartEmbedTransformersNodeAdapter = class extends SmartEmbed {\n      // async init(this.model_name = 'Xenova/bge-small-en-v1.5') {\n      async init() {\n        const { env, pipeline, AutoTokenizer } = await import(\"@xenova/transformers\");\n        env.allowLocalModels = false;\n        this.model = await pipeline(\"feature-extraction\", this.model_name, { quantized: true, max_length: this.config.max_tokens });\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);\n      }\n      async embed_batch(items) {\n        items = items.filter((item) => {\n          var _a;\n          return ((_a = item.embed_input) == null ? void 0 : _a.length) > 0;\n        });\n        if (!(items == null ? void 0 : items.length))\n          return [];\n        const tokens = await Promise.all(items.map((item) => this.count_tokens(item.embed_input)));\n        const embed_input = await Promise.all(items.map(async (item, i) => {\n          if (tokens[i] < this.config.max_tokens)\n            return item.embed_input;\n          let token_ct = tokens[i];\n          let truncated_input = item.embed_input;\n          while (token_ct > this.config.max_tokens) {\n            const pct = this.config.max_tokens / token_ct;\n            const max_chars = Math.floor(truncated_input.length * pct * 0.9);\n            truncated_input = truncated_input.substring(0, max_chars) + \"...\";\n            token_ct = await this.count_tokens(truncated_input);\n          }\n          tokens[i] = token_ct;\n          return truncated_input;\n        }));\n        try {\n          const resp2 = await this.model(embed_input, { pooling: \"mean\", normalize: true });\n          return items.map((item, i) => {\n            item.vec = Array.from(resp2[i].data);\n            item.tokens = tokens[i];\n            return item;\n          });\n        } catch (err) {\n          console.log(err);\n          console.log(\"Error embedding batch. Trying one at a time...\");\n        }\n        const resp = await Promise.all(items.map(async (item) => {\n          const { vec, tokens: tokens2, error } = await this.embed(item.embed_input);\n          if (error) {\n            console.log(\"Error embedding item: \", item.key);\n            console.log(error);\n            item.error = error;\n            return item;\n          }\n          if (!vec) {\n            console.log(\"Error embedding item: \", item.key);\n            console.log(\"Vec: \", vec);\n            console.log(\"Error: \", error);\n            console.log(\"Tokens: \", tokens2);\n            console.log(\"No vec returned\");\n            item.error = \"No vec returned\";\n            return item;\n          }\n          item.vec = vec.map((val) => Math.round(val * 1e8) / 1e8);\n          item.tokens = tokens2;\n          return item;\n        }));\n        return resp;\n      }\n      async embed(input) {\n        const output = { embed_input: input };\n        if (!input)\n          return { ...output, error: \"No input text.\" };\n        if (!this.model)\n          await this.init();\n        try {\n          output.tokens = await this.count_tokens(input);\n          if (output.tokens < 1)\n            return { ...output, error: \"Input too short.\" };\n          if (output.tokens < this.config.max_tokens) {\n            const embedding = await this.model(input, { pooling: \"mean\", normalize: true });\n            output.vec = Array.from(embedding.data).map((val) => Math.round(val * 1e8) / 1e8);\n          } else {\n            const pct = this.config.max_tokens / output.tokens;\n            const max_chars = Math.floor(input.length * pct * 0.95);\n            input = input.substring(0, max_chars) + \"...\";\n            output.truncated = true;\n            console.log(\"Input too long. Truncating to \", input.length, \" characters.\");\n            const { vec, tokens } = await this.embed(input);\n            output.vec = vec;\n            output.tokens = tokens;\n          }\n          return output;\n        } catch (err) {\n          console.log(err);\n          return { ...output, error: err.message };\n        }\n      }\n      async count_tokens(text) {\n        if (!this.tokenizer)\n          await this.init();\n        const { input_ids } = await this.tokenizer(text);\n        return input_ids.data.length;\n      }\n    };\n    exports.SmartEmbedTransformersNodeAdapter = SmartEmbedTransformersNodeAdapter;\n    exports.SmartEmbedLocalAdapter = SmartEmbedTransformersNodeAdapter;\n  }\n});\n\n// SmartEmbedTransformersWebConnector.js\nvar require_SmartEmbedTransformersWebConnector = __commonJS({\n  \"SmartEmbedTransformersWebConnector.js\"(exports) {\n    var { SmartEmbedTransformersNodeAdapter } = require_SmartEmbedTransformersNodeAdapter();\n    var models = require_models();\n    var SmartEmbedTransformersWebConnector = class extends SmartEmbedTransformersNodeAdapter {\n      constructor(model_config_key, window2) {\n        super(model_config_key);\n        this.model = null;\n        this.running_init = false;\n        this.window = window2;\n        this.embed_ct = 0;\n        this.timestamp = null;\n        this.tokens = 0;\n      }\n      async init() {\n        if (this.model)\n          return console.log(\"Smart Local Model already loaded\");\n        if (this.running_init)\n          await new Promise((resolve) => setTimeout(resolve, 3e3));\n        if (!this.model && !this.running_init)\n          this.running_init = true;\n        console.log(\"Loading Smart Local Model\");\n        const { pipeline, env, AutoTokenizer } = await import(\"https://cdn.jsdelivr.net/npm/@xenova/transformers@latest\");\n        env.allowLocalModels = false;\n        this.model = await pipeline(\"feature-extraction\", this.model_name, { quantized: true });\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);\n        this.running_init = false;\n        this.window.tokenizer = this.tokenizer;\n        console.log(await this.embed(\"test\"));\n        this.window.parent.postMessage({ type: \"model_loaded\", data: true }, \"*\");\n        this.window.addEventListener(\"message\", this.handle_ipc.bind(this), false);\n      }\n      async handle_ipc(event) {\n        if (event.data.type == \"smart_embed\")\n          this.embed_handler(event.data);\n        if (event.data.type == \"smart_embed_token_ct\")\n          this.count_tokens_handler(event.data.embed_input);\n      }\n      async embed_handler(event_data) {\n        const { embed_input, handler_id } = event_data;\n        if (!this.timestamp)\n          this.timestamp = Date.now();\n        if (Array.isArray(embed_input)) {\n          const resp = await this.embed_batch(embed_input);\n          const send_data = {\n            type: \"smart_embed_resp\",\n            handler_id,\n            data: resp\n          };\n          this.window.postMessage(send_data, \"*\");\n          this.tokens += resp.reduce((acc, item) => acc + item.tokens, 0);\n          this.embed_ct += resp.length;\n        } else {\n          if (!this.timestamp)\n            this.timestamp = Date.now();\n          const send_data = await this.embed(embed_input);\n          send_data.type = \"smart_embed_resp\";\n          if (handler_id)\n            send_data.handler_id = handler_id;\n          this.window.postMessage(send_data, \"*\");\n          this.tokens += send_data.tokens;\n          this.embed_ct++;\n        }\n        if (Date.now() - this.timestamp > 1e4) {\n          console.log(`Embedded: ${this.embed_ct} inputs (${this.tokens} tokens, ${(this.tokens / ((Date.now() - this.timestamp) / 1e3)).toFixed(0)} tokens/sec)`);\n          this.timestamp = null;\n          this.tokens = 0;\n          this.embed_ct = 0;\n        }\n      }\n      async count_tokens_handler(input) {\n        const output = await this.count_tokens(input);\n        const send_data = {\n          type: \"smart_embed_token_ct\",\n          text: \"count:\" + input,\n          count: output\n        };\n        this.window.postMessage(send_data, \"*\");\n      }\n    };\n    exports.SmartEmbedTransformersWebConnector = SmartEmbedTransformersWebConnector;\n  }\n});\n\n// smart_embed_web.js\nwindow.addEventListener(\"message\", init);\nasync function init(event) {\n  if (event.data.type === \"init\") {\n    window.removeEventListener(\"message\", init);\n    const model_config = event.data.model_config_key;\n    const { SmartEmbedTransformersWebConnector } = await Promise.resolve().then(() => __toESM(require_SmartEmbedTransformersWebConnector()));\n    const model = await SmartEmbedTransformersWebConnector.create(model_config, window);\n    window.model = model;\n  }\n}\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibW9kZWxzLmpzb24iLCAiU21hcnRFbWJlZC5qcyIsICJTbWFydEVtYmVkVHJhbnNmb3JtZXJzTm9kZUFkYXB0ZXIuanMiLCAiU21hcnRFbWJlZFRyYW5zZm9ybWVyc1dlYkNvbm5lY3Rvci5qcyIsICJzbWFydF9lbWJlZF93ZWIuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIntcbiAgXCJUYXlsb3JBSS9iZ2UtbWljcm8tdjJcIjoge1xuICAgIFwibW9kZWxfbmFtZVwiOiBcIlRheWxvckFJL2JnZS1taWNyby12MlwiLFxuICAgIFwiYmF0Y2hfc2l6ZVwiOiAxLFxuICAgIFwiZGltc1wiOiAzODQsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDUxMixcbiAgICBcIm5hbWVcIjogXCJCR0UtbWljcm8tdjJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTG9jYWwsIDUxMiB0b2tlbnMsIDM4NCBkaW1cIixcbiAgICBcInR5cGVcIjogXCJodWdnaW5nZmFjZS10cmFuc2Zvcm1lcnNcIlxuICB9LFxuICBcImFuZGVyc29uYmNkZWZnL2JnZS1zbWFsbC00MDk2XCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJhbmRlcnNvbmJjZGVmZy9iZ2Utc21hbGwtNDA5NlwiLFxuICAgIFwiYmF0Y2hfc2l6ZVwiOiAxLFxuICAgIFwiZGltc1wiOiAzODQsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDQwOTYsXG4gICAgXCJuYW1lXCI6IFwiQkdFLXNtYWxsLTRLXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkxvY2FsLCA0LDA5NiB0b2tlbnMsIDM4NCBkaW1cIixcbiAgICBcInR5cGVcIjogXCJodWdnaW5nZmFjZS10cmFuc2Zvcm1lcnNcIlxuICB9LFxuICBcIlhlbm92YS9qaW5hLWVtYmVkZGluZ3MtdjItYmFzZS16aC04MTkyXCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJYZW5vdmEvamluYS1lbWJlZGRpbmdzLXYyLWJhc2UtemhcIixcbiAgICBcImJhdGNoX3NpemVcIjogMSxcbiAgICBcImRpbXNcIjogNTEyLFxuICAgIFwibWF4X3Rva2Vuc1wiOiA4MTkyLFxuICAgIFwibmFtZVwiOiBcIkppbmEtdjItYmFzZS16aC04S1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJMb2NhbCwgOCwxOTIgdG9rZW5zLCA1MTIgZGltLCBDaGluZXNlL0VuZ2xpc2ggYmlsaW5ndWFsXCIsXG4gICAgXCJ0eXBlXCI6IFwiaHVnZ2luZ2ZhY2UtdHJhbnNmb3JtZXJzXCJcbiAgfSxcbiAgXCJ0ZXh0LWVtYmVkZGluZy0zLXNtYWxsXCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJ0ZXh0LWVtYmVkZGluZy0zLXNtYWxsXCIsXG4gICAgXCJiYXRjaF9zaXplXCI6IDUwLFxuICAgIFwiZGltc1wiOiAxNTM2LFxuICAgIFwibWF4X3Rva2Vuc1wiOiA4MTkxLFxuICAgIFwibmFtZVwiOiBcIk9wZW5BSSBUZXh0LTMgU21hbGxcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQVBJLCA4LDE5MSB0b2tlbnMsIDEsNTM2IGRpbVwiLFxuICAgIFwidHlwZVwiOiBcIm9wZW5haVwiXG4gIH0sXG4gIFwidGV4dC1lbWJlZGRpbmctMy1sYXJnZVwiOiB7XG4gICAgXCJtb2RlbF9uYW1lXCI6IFwidGV4dC1lbWJlZGRpbmctMy1sYXJnZVwiLFxuICAgIFwiYmF0Y2hfc2l6ZVwiOiA1MCxcbiAgICBcImRpbXNcIjogMzA3MixcbiAgICBcIm1heF90b2tlbnNcIjogODE5MSxcbiAgICBcIm5hbWVcIjogXCJPcGVuQUkgVGV4dC0zIExhcmdlXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFQSSwgOCwxOTEgdG9rZW5zLCAzLDA3MiBkaW1cIixcbiAgICBcInR5cGVcIjogXCJvcGVuYWlcIlxuICB9LFxuICBcInRleHQtZW1iZWRkaW5nLTMtc21hbGwtNTEyXCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJ0ZXh0LWVtYmVkZGluZy0zLXNtYWxsXCIsXG4gICAgXCJiYXRjaF9zaXplXCI6IDUwLFxuICAgIFwiZGltc1wiOiA1MTIsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDgxOTEsXG4gICAgXCJuYW1lXCI6IFwiT3BlbkFJIFRleHQtMyBTbWFsbCAtIDUxMlwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBUEksIDgsMTkxIHRva2VucywgNTEyIGRpbVwiLFxuICAgIFwidHlwZVwiOiBcIm9wZW5haVwiXG4gIH0sXG4gIFwidGV4dC1lbWJlZGRpbmctMy1sYXJnZS0yNTZcIjoge1xuICAgIFwibW9kZWxfbmFtZVwiOiBcInRleHQtZW1iZWRkaW5nLTMtbGFyZ2VcIixcbiAgICBcImJhdGNoX3NpemVcIjogNTAsXG4gICAgXCJkaW1zXCI6IDI1NixcbiAgICBcIm1heF90b2tlbnNcIjogODE5MSxcbiAgICBcIm5hbWVcIjogXCJPcGVuQUkgVGV4dC0zIExhcmdlIC0gMjU2XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFQSSwgOCwxOTEgdG9rZW5zLCAyNTYgZGltXCIsXG4gICAgXCJ0eXBlXCI6IFwib3BlbmFpXCJcbiAgfSxcbiAgXCJ0ZXh0LWVtYmVkZGluZy1hZGEtMDAyXCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJ0ZXh0LWVtYmVkZGluZy1hZGEtMDAyXCIsXG4gICAgXCJiYXRjaF9zaXplXCI6IDUwLFxuICAgIFwiZGltc1wiOiAxNTM2LFxuICAgIFwibWF4X3Rva2Vuc1wiOiA4MTkxLFxuICAgIFwibmFtZVwiOiBcIk9wZW5BSSBBZGFcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQVBJLCA4LDE5MSB0b2tlbnMsIDEsNTM2IGRpbVwiLFxuICAgIFwidHlwZVwiOiBcIm9wZW5haVwiXG4gIH0sXG4gIFwiWGVub3ZhL2ppbmEtZW1iZWRkaW5ncy12Mi1zbWFsbC1lblwiOiB7XG4gICAgXCJtb2RlbF9uYW1lXCI6IFwiWGVub3ZhL2ppbmEtZW1iZWRkaW5ncy12Mi1zbWFsbC1lblwiLFxuICAgIFwiYmF0Y2hfc2l6ZVwiOiAxLFxuICAgIFwiZGltc1wiOiA1MTIsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDgxOTIsXG4gICAgXCJuYW1lXCI6IFwiSmluYS12Mi1zbWFsbC1lblwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJMb2NhbCwgOCwxOTIgdG9rZW5zLCA1MTIgZGltXCIsXG4gICAgXCJ0eXBlXCI6IFwiaHVnZ2luZ2ZhY2UtdHJhbnNmb3JtZXJzXCJcbiAgfSxcbiAgXCJub21pYy1haS9ub21pYy1lbWJlZC10ZXh0LXYxLjUtMjU2XCI6IHtcbiAgICBcIm1vZGVsX25hbWVcIjogXCJub21pYy1haS9ub21pYy1lbWJlZC10ZXh0LXYxLjVcIixcbiAgICBcImJhdGNoX3NpemVcIjogMSxcbiAgICBcImRpbXNcIjogMjU2LFxuICAgIFwibWF4X3Rva2Vuc1wiOiA4MTkyLFxuICAgIFwibmFtZVwiOiBcIk5vbWljLWVtYmVkLXRleHQtdjEuNVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJMb2NhbCwgOCwxOTIgdG9rZW5zLCAyNTYgZGltXCIsXG4gICAgXCJ0eXBlXCI6IFwiaHVnZ2luZ2ZhY2UtdHJhbnNmb3JtZXJzXCJcbiAgfSxcbiAgXCJYZW5vdmEvYmdlLXNtYWxsLWVuLXYxLjVcIjoge1xuICAgIFwibW9kZWxfbmFtZVwiOiBcIlhlbm92YS9iZ2Utc21hbGwtZW4tdjEuNVwiLFxuICAgIFwiYmF0Y2hfc2l6ZVwiOiAxLFxuICAgIFwiZGltc1wiOiAzODQsXG4gICAgXCJtYXhfdG9rZW5zXCI6IDUxMixcbiAgICBcIm5hbWVcIjogXCJCR0Utc21hbGxcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTG9jYWwsIDUxMiB0b2tlbnMsIDM4NCBkaW1cIixcbiAgICBcInR5cGVcIjogXCJodWdnaW5nZmFjZS10cmFuc2Zvcm1lcnNcIlxuICB9LFxuICBcIm5vbWljLWFpL25vbWljLWVtYmVkLXRleHQtdjFcIjoge1xuICAgIFwibW9kZWxfbmFtZVwiOiBcIm5vbWljLWFpL25vbWljLWVtYmVkLXRleHQtdjFcIixcbiAgICBcImJhdGNoX3NpemVcIjogMSxcbiAgICBcImRpbXNcIjogNzY4LFxuICAgIFwibWF4X3Rva2Vuc1wiOiAyMDQ4LFxuICAgIFwibmFtZVwiOiBcIk5vbWljLWVtYmVkLXRleHRcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTG9jYWwsIDIsMDQ4IHRva2VucywgNzY4IGRpbVwiLFxuICAgIFwidHlwZVwiOiBcImh1Z2dpbmdmYWNlLXRyYW5zZm9ybWVyc1wiXG4gIH1cbn0iLCAiY29uc3QgbW9kZWxzID0gcmVxdWlyZSgnLi9tb2RlbHMnKTtcbmNsYXNzIFNtYXJ0RW1iZWQge1xuICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgIGlmKHR5cGVvZiBtb2RlbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuY29uZmlnID0gey4uLm1vZGVsfTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMubW9kZWxfY29uZmlnX2tleSA9IG1vZGVsO1xuICAgICAgdGhpcy5jb25maWcgPSBtb2RlbHNbdGhpcy5tb2RlbF9jb25maWdfa2V5XTtcbiAgICB9XG4gICAgLy8gc3RhdHNcbiAgICB0aGlzLmVtYmVkX2N0ID0gMDtcbiAgICB0aGlzLnRpbWVzdGFtcCA9IG51bGw7XG4gICAgdGhpcy50b2tlbnMgPSAwO1xuICB9XG4gIHN0YXRpYyBhc3luYyBjcmVhdGUobW9kZWxfY29uZmlnX2tleSwgLi4uYXJncykge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBuZXcgdGhpcyhtb2RlbF9jb25maWdfa2V5LCAuLi5hcmdzKTtcbiAgICBhd2FpdCBhZGFwdGVyLmluaXQoKTtcbiAgICByZXR1cm4gYWRhcHRlcjtcbiAgfVxuICBhc3luYyBpbml0KCkgeyB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn1cbiAgICovXG4gIGFzeW5jIGNvdW50X3Rva2VucyhpbnB1dCkgeyB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyW10+fVxuICAgKi9cbiAgYXN5bmMgZW1iZWQoaW5wdXQpIHsgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gaW5wdXRcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyW11bXT59XG4gICAqL1xuICBhc3luYyBlbWJlZF9iYXRjaChpbnB1dCkgeyB9XG4gIGdldCBiYXRjaF9zaXplKCkgeyByZXR1cm4gdGhpcy5jb25maWcuYmF0Y2hfc2l6ZTsgfVxuICBnZXQgZGltcygpIHsgcmV0dXJuIHRoaXMuY29uZmlnLmRpbXM7IH1cbiAgZ2V0IG1heF90b2tlbnMoKSB7IHJldHVybiB0aGlzLmNvbmZpZy5tYXhfdG9rZW5zOyB9XG4gIGdldCBtb2RlbF9uYW1lKCkgeyByZXR1cm4gdGhpcy5jb25maWcubW9kZWxfbmFtZTsgfVxufVxuXG5leHBvcnRzLlNtYXJ0RW1iZWQgPSBTbWFydEVtYmVkOyIsICJjb25zdCB7IFNtYXJ0RW1iZWQgfSA9IHJlcXVpcmUoXCIuL1NtYXJ0RW1iZWRcIik7XG5cbmNsYXNzIFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNOb2RlQWRhcHRlciBleHRlbmRzIFNtYXJ0RW1iZWQge1xuICAvLyBhc3luYyBpbml0KHRoaXMubW9kZWxfbmFtZSA9ICdYZW5vdmEvYmdlLXNtYWxsLWVuLXYxLjUnKSB7XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgY29uc3QgeyBlbnYsIHBpcGVsaW5lLCBBdXRvVG9rZW5pemVyIH0gPSBhd2FpdCBpbXBvcnQoJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJyk7XG4gICAgZW52LmFsbG93TG9jYWxNb2RlbHMgPSBmYWxzZTtcbiAgICB0aGlzLm1vZGVsID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsIHRoaXMubW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IHRydWUsIG1heF9sZW5ndGg6IHRoaXMuY29uZmlnLm1heF90b2tlbnMgfSk7XG4gICAgLy8gdGhpcy5tb2RlbCA9IGF3YWl0IHBpcGVsaW5lKCdmZWF0dXJlLWV4dHJhY3Rpb24nLCB0aGlzLm1vZGVsX25hbWUsIHsgcXVhbnRpemVkOiBmYWxzZSB9KTtcbiAgICB0aGlzLnRva2VuaXplciA9IGF3YWl0IEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKHRoaXMubW9kZWxfbmFtZSk7XG4gIH1cbiAgYXN5bmMgZW1iZWRfYmF0Y2goaXRlbXMpIHtcbiAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uZW1iZWRfaW5wdXQ/Lmxlbmd0aCA+IDApOyAvLyByZW1vdmUgaXRlbXMgd2l0aCBlbXB0eSBlbWJlZF9pbnB1dCAoY2F1c2VzIC5zcGxpdCgpIGVycm9yKVxuICAgIGlmKCFpdGVtcz8ubGVuZ3RoKSByZXR1cm4gW107XG4gICAgY29uc3QgdG9rZW5zID0gYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGl0ZW0gPT4gdGhpcy5jb3VudF90b2tlbnMoaXRlbS5lbWJlZF9pbnB1dCkpKTtcbiAgICBjb25zdCBlbWJlZF9pbnB1dCA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChhc3luYyAoaXRlbSwgaSkgPT4ge1xuICAgICAgaWYgKHRva2Vuc1tpXSA8IHRoaXMuY29uZmlnLm1heF90b2tlbnMpIHJldHVybiBpdGVtLmVtYmVkX2lucHV0O1xuICAgICAgbGV0IHRva2VuX2N0ID0gdG9rZW5zW2ldO1xuICAgICAgbGV0IHRydW5jYXRlZF9pbnB1dCA9IGl0ZW0uZW1iZWRfaW5wdXQ7XG4gICAgICB3aGlsZSAodG9rZW5fY3QgPiB0aGlzLmNvbmZpZy5tYXhfdG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IHBjdCA9IHRoaXMuY29uZmlnLm1heF90b2tlbnMgLyB0b2tlbl9jdDsgLy8gZ2V0IHBjdCBvZiBpbnB1dCB0byBrZWVwXG4gICAgICAgIGNvbnN0IG1heF9jaGFycyA9IE1hdGguZmxvb3IodHJ1bmNhdGVkX2lucHV0Lmxlbmd0aCAqIHBjdCAqIDAuOTApOyAvLyBnZXQgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8ga2VlcCAobWludXMgMTAlIGZvciBzYWZldHkpXG4gICAgICAgIHRydW5jYXRlZF9pbnB1dCA9IHRydW5jYXRlZF9pbnB1dC5zdWJzdHJpbmcoMCwgbWF4X2NoYXJzKSArIFwiLi4uXCI7XG4gICAgICAgIHRva2VuX2N0ID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnModHJ1bmNhdGVkX2lucHV0KTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbnNvbGUubG9nKFwiSW5wdXQgdG9vIGxvbmcuIFRydW5jYXRpbmcgdG8gXCIsIHRydW5jYXRlZF9pbnB1dC5sZW5ndGgsIFwiIGNoYXJhY3RlcnMuXCIpO1xuICAgICAgLy8gY29uc29sZS5sb2coXCJUb2tlbnM6IFwiLCB0b2tlbnNbaV0sIFwiIC0+IFwiLCB0b2tlbl9jdCk7XG4gICAgICB0b2tlbnNbaV0gPSB0b2tlbl9jdDtcbiAgICAgIHJldHVybiB0cnVuY2F0ZWRfaW5wdXQ7XG4gICAgfSkpO1xuXG4gICAgLy8gY29uc29sZS5sb2coZW1iZWRfaW5wdXQpO1xuICAgIHRyeXtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLm1vZGVsKGVtYmVkX2lucHV0LCB7IHBvb2xpbmc6ICdtZWFuJywgbm9ybWFsaXplOiB0cnVlIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2cocmVzcCk7XG4gICAgICByZXR1cm4gaXRlbXMubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGl0ZW0udmVjID0gQXJyYXkuZnJvbShyZXNwW2ldLmRhdGEpO1xuICAgICAgICBpdGVtLnRva2VucyA9IHRva2Vuc1tpXTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9KTtcbiAgICB9Y2F0Y2goZXJyKXtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGVtYmVkZGluZyBiYXRjaC4gVHJ5aW5nIG9uZSBhdCBhIHRpbWUuLi5cIik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoYXN5bmMgaXRlbSA9PiB7XG4gICAgICBjb25zdCB7IHZlYywgdG9rZW5zLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5lbWJlZChpdGVtLmVtYmVkX2lucHV0KTtcbiAgICAgIGlmKGVycm9yKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBlbWJlZGRpbmcgaXRlbTogXCIsIGl0ZW0ua2V5KTtcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICBpdGVtLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgICAgaWYoIXZlYyl7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZW1iZWRkaW5nIGl0ZW06IFwiLCBpdGVtLmtleSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVmVjOiBcIiwgdmVjKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvcjogXCIsIGVycm9yKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJUb2tlbnM6IFwiLCB0b2tlbnMpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHZlYyByZXR1cm5lZFwiKTtcbiAgICAgICAgaXRlbS5lcnJvciA9IFwiTm8gdmVjIHJldHVybmVkXCI7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgICAgaXRlbS52ZWMgPSB2ZWMubWFwKHZhbCA9PiBNYXRoLnJvdW5kKHZhbCAqIDEwMDAwMDAwMCkgLyAxMDAwMDAwMDApOyAvLyByZWR1Y2UgcHJlY2lzaW9uIHRvIDggZGVjaW1hbCBwbGFjZXMgcmVmOiBodHRwczovL3dmaGJyaWFuLmNvbS92ZWN0b3ItZGltZW5zaW9uLXByZWNpc2lvbi1lZmZlY3Qtb24tY29zaW5lLXNpbWlsYXJpdHkvXG4gICAgICBpdGVtLnRva2VucyA9IHRva2VucztcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pKTtcbiAgICByZXR1cm4gcmVzcDtcbiAgfVxuICBhc3luYyBlbWJlZChpbnB1dCkge1xuICAgIGNvbnN0IG91dHB1dCA9IHsgZW1iZWRfaW5wdXQ6IGlucHV0IH07XG4gICAgaWYgKCFpbnB1dCkgcmV0dXJuIHsgLi4ub3V0cHV0LCBlcnJvcjogXCJObyBpbnB1dCB0ZXh0LlwiIH07XG4gICAgaWYgKCF0aGlzLm1vZGVsKSBhd2FpdCB0aGlzLmluaXQoKTtcbiAgICB0cnkge1xuICAgICAgb3V0cHV0LnRva2VucyA9IGF3YWl0IHRoaXMuY291bnRfdG9rZW5zKGlucHV0KTtcbiAgICAgIGlmIChvdXRwdXQudG9rZW5zIDwgMSkgcmV0dXJuIHsgLi4ub3V0cHV0LCBlcnJvcjogXCJJbnB1dCB0b28gc2hvcnQuXCIgfTtcbiAgICAgIGlmIChvdXRwdXQudG9rZW5zIDwgdGhpcy5jb25maWcubWF4X3Rva2Vucykge1xuICAgICAgICBjb25zdCBlbWJlZGRpbmcgPSBhd2FpdCB0aGlzLm1vZGVsKGlucHV0LCB7IHBvb2xpbmc6ICdtZWFuJywgbm9ybWFsaXplOiB0cnVlIH0pO1xuICAgICAgICBvdXRwdXQudmVjID0gQXJyYXkuZnJvbShlbWJlZGRpbmcuZGF0YSkubWFwKHZhbCA9PiBNYXRoLnJvdW5kKHZhbCAqIDEwMDAwMDAwMCkgLyAxMDAwMDAwMDApOyAvLyByZWR1Y2UgcHJlY2lzaW9uIHRvIDggZGVjaW1hbCBwbGFjZXMgcmVmOiBodHRwczovL3dmaGJyaWFuLmNvbS92ZWN0b3ItZGltZW5zaW9uLXByZWNpc2lvbi1lZmZlY3Qtb24tY29zaW5lLXNpbWlsYXJpdHkvXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwY3QgPSB0aGlzLmNvbmZpZy5tYXhfdG9rZW5zIC8gb3V0cHV0LnRva2VuczsgLy8gZ2V0IHBjdCBvZiBpbnB1dCB0byBrZWVwXG4gICAgICAgIGNvbnN0IG1heF9jaGFycyA9IE1hdGguZmxvb3IoaW5wdXQubGVuZ3RoICogcGN0ICogMC45NSk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyA1JSBmb3Igc2FmZXR5KVxuICAgICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXCIuLi5cIjtcbiAgICAgICAgb3V0cHV0LnRydW5jYXRlZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5wdXQgdG9vIGxvbmcuIFRydW5jYXRpbmcgdG8gXCIsIGlucHV0Lmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIik7XG4gICAgICAgIGNvbnN0IHsgdmVjLCB0b2tlbnMgfSA9IGF3YWl0IHRoaXMuZW1iZWQoaW5wdXQpO1xuICAgICAgICBvdXRwdXQudmVjID0gdmVjO1xuICAgICAgICBvdXRwdXQudG9rZW5zID0gdG9rZW5zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBlcnIubWVzc2FnZSB9O1xuICAgIH1cbiAgfVxuICBhc3luYyBjb3VudF90b2tlbnModGV4dCkge1xuICAgIGlmICghdGhpcy50b2tlbml6ZXIpIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGNvbnN0IHsgaW5wdXRfaWRzIH0gPSBhd2FpdCB0aGlzLnRva2VuaXplcih0ZXh0KTtcbiAgICByZXR1cm4gaW5wdXRfaWRzLmRhdGEubGVuZ3RoOyAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiB0b2tlbnNcbiAgfVxufVxuXG5leHBvcnRzLlNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNOb2RlQWRhcHRlciA9IFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNOb2RlQWRhcHRlcjtcbmV4cG9ydHMuU21hcnRFbWJlZExvY2FsQWRhcHRlciA9IFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNOb2RlQWRhcHRlcjsgLy8gYWxpYXMiLCAiY29uc3QgeyBTbWFydEVtYmVkVHJhbnNmb3JtZXJzTm9kZUFkYXB0ZXIgfSA9IHJlcXVpcmUoJy4vU21hcnRFbWJlZFRyYW5zZm9ybWVyc05vZGVBZGFwdGVyJyk7XG5jb25zdCBtb2RlbHMgPSByZXF1aXJlKCcuL21vZGVscycpO1xuXG4vLyBDT05ORUNUT1IgRk9SIE9CU0lESUFOXG5jbGFzcyBTbWFydEVtYmVkVHJhbnNmb3JtZXJzV2ViQ29ubmVjdG9yIGV4dGVuZHMgU21hcnRFbWJlZFRyYW5zZm9ybWVyc05vZGVBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IobW9kZWxfY29uZmlnX2tleSwgd2luZG93KSB7XG4gICAgc3VwZXIobW9kZWxfY29uZmlnX2tleSk7XG4gICAgdGhpcy5tb2RlbCA9IG51bGw7XG4gICAgdGhpcy5ydW5uaW5nX2luaXQgPSBmYWxzZTtcbiAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgICAvLyBzdGF0c1xuICAgIHRoaXMuZW1iZWRfY3QgPSAwO1xuICAgIHRoaXMudGltZXN0YW1wID0gbnVsbDtcbiAgICB0aGlzLnRva2VucyA9IDA7XG4gIH1cbiAgYXN5bmMgaW5pdCgpIHtcbiAgICBpZiAodGhpcy5tb2RlbCkgcmV0dXJuIGNvbnNvbGUubG9nKFwiU21hcnQgTG9jYWwgTW9kZWwgYWxyZWFkeSBsb2FkZWRcIik7XG4gICAgaWYgKHRoaXMucnVubmluZ19pbml0KSBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwMCkpO1xuICAgIGlmICghdGhpcy5tb2RlbCAmJiAhdGhpcy5ydW5uaW5nX2luaXQpIHRoaXMucnVubmluZ19pbml0ID0gdHJ1ZTtcbiAgICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgU21hcnQgTG9jYWwgTW9kZWxcIik7XG4gICAgLy8gY29uc3QgeyBwaXBlbGluZSwgZW52LCBBdXRvVG9rZW5pemVyIH0gPSBhd2FpdCBpbXBvcnQoJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHhlbm92YS90cmFuc2Zvcm1lcnNAMi4xMy4wJyk7XG4gICAgY29uc3QgeyBwaXBlbGluZSwgZW52LCBBdXRvVG9rZW5pemVyIH0gPSBhd2FpdCBpbXBvcnQoJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHhlbm92YS90cmFuc2Zvcm1lcnNAbGF0ZXN0Jyk7XG4gICAgZW52LmFsbG93TG9jYWxNb2RlbHMgPSBmYWxzZTtcbiAgICB0aGlzLm1vZGVsID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsIHRoaXMubW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IHRydWUgfSk7XG4gICAgdGhpcy50b2tlbml6ZXIgPSBhd2FpdCBBdXRvVG9rZW5pemVyLmZyb21fcHJldHJhaW5lZCh0aGlzLm1vZGVsX25hbWUpO1xuICAgIHRoaXMucnVubmluZ19pbml0ID0gZmFsc2U7XG4gICAgdGhpcy53aW5kb3cudG9rZW5pemVyID0gdGhpcy50b2tlbml6ZXI7XG4gICAgY29uc29sZS5sb2coYXdhaXQgdGhpcy5lbWJlZChcInRlc3RcIikpO1xuICAgIHRoaXMud2luZG93LnBhcmVudC5wb3N0TWVzc2FnZSh7IHR5cGU6IFwibW9kZWxfbG9hZGVkXCIsIGRhdGE6IHRydWUgfSwgXCIqXCIpOyAvLyBwb3N0IG1lc3NhZ2UgdG8gcGFyZW50IHRoYXQgbW9kZWwgaXMgbG9hZGVkXG4gICAgdGhpcy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5oYW5kbGVfaXBjLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgfVxuICBhc3luYyBoYW5kbGVfaXBjKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PSBcInNtYXJ0X2VtYmVkXCIpIHRoaXMuZW1iZWRfaGFuZGxlcihldmVudC5kYXRhKTtcbiAgICAvLyBpZiAoZXZlbnQuZGF0YS50eXBlID09IFwic21hcnRfZW1iZWRfYmF0Y2hcIikgdGhpcy5lbWJlZF9iYXRjaF9oYW5kbGVyKGV2ZW50LmRhdGEuZW1iZWRfaW5wdXQpO1xuICAgIGlmIChldmVudC5kYXRhLnR5cGUgPT0gXCJzbWFydF9lbWJlZF90b2tlbl9jdFwiKSB0aGlzLmNvdW50X3Rva2Vuc19oYW5kbGVyKGV2ZW50LmRhdGEuZW1iZWRfaW5wdXQpO1xuICB9XG4gIGFzeW5jIGVtYmVkX2hhbmRsZXIoZXZlbnRfZGF0YSkge1xuICAgIGNvbnN0IHsgZW1iZWRfaW5wdXQsIGhhbmRsZXJfaWQgfSA9IGV2ZW50X2RhdGE7XG4gICAgLy8gY29uc29sZS5sb2coZW1iZWRfaW5wdXQpO1xuICAgIGlmKCF0aGlzLnRpbWVzdGFtcCkgdGhpcy50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGlmKEFycmF5LmlzQXJyYXkoZW1iZWRfaW5wdXQpKSB7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5lbWJlZF9iYXRjaChlbWJlZF9pbnB1dCk7XG4gICAgICBjb25zdCBzZW5kX2RhdGEgPSB7XG4gICAgICAgIHR5cGU6IFwic21hcnRfZW1iZWRfcmVzcFwiLFxuICAgICAgICBoYW5kbGVyX2lkLFxuICAgICAgICBkYXRhOiByZXNwLFxuICAgICAgfTtcbiAgICAgIHRoaXMud2luZG93LnBvc3RNZXNzYWdlKHNlbmRfZGF0YSwgXCIqXCIpO1xuICAgICAgdGhpcy50b2tlbnMgKz0gcmVzcC5yZWR1Y2UoKGFjYywgaXRlbSkgPT4gYWNjICsgaXRlbS50b2tlbnMsIDApO1xuICAgICAgdGhpcy5lbWJlZF9jdCArPSByZXNwLmxlbmd0aDtcbiAgICB9ZWxzZXtcbiAgICAgIGlmICghdGhpcy50aW1lc3RhbXApIHRoaXMudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHNlbmRfZGF0YSA9IGF3YWl0IHRoaXMuZW1iZWQoZW1iZWRfaW5wdXQpO1xuICAgICAgc2VuZF9kYXRhLnR5cGUgPSBcInNtYXJ0X2VtYmVkX3Jlc3BcIjtcbiAgICAgIGlmIChoYW5kbGVyX2lkKSBzZW5kX2RhdGEuaGFuZGxlcl9pZCA9IGhhbmRsZXJfaWQ7XG4gICAgICB0aGlzLndpbmRvdy5wb3N0TWVzc2FnZShzZW5kX2RhdGEsIFwiKlwiKTtcbiAgICAgIHRoaXMudG9rZW5zICs9IHNlbmRfZGF0YS50b2tlbnM7XG4gICAgICB0aGlzLmVtYmVkX2N0Kys7XG4gICAgfVxuICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy50aW1lc3RhbXAgPiAxMDAwMCkge1xuICAgICAgY29uc29sZS5sb2coYEVtYmVkZGVkOiAke3RoaXMuZW1iZWRfY3R9IGlucHV0cyAoJHt0aGlzLnRva2Vuc30gdG9rZW5zLCAkeyh0aGlzLnRva2VucyAvICgoRGF0ZS5ub3coKSAtIHRoaXMudGltZXN0YW1wKSAvIDEwMDApKS50b0ZpeGVkKDApfSB0b2tlbnMvc2VjKWApO1xuICAgICAgdGhpcy50aW1lc3RhbXAgPSBudWxsO1xuICAgICAgdGhpcy50b2tlbnMgPSAwO1xuICAgICAgdGhpcy5lbWJlZF9jdCA9IDA7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNvdW50X3Rva2Vuc19oYW5kbGVyKGlucHV0KSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnMoaW5wdXQpO1xuICAgIGNvbnN0IHNlbmRfZGF0YSA9IHtcbiAgICAgIHR5cGU6IFwic21hcnRfZW1iZWRfdG9rZW5fY3RcIixcbiAgICAgIHRleHQ6IFwiY291bnQ6XCIgKyBpbnB1dCxcbiAgICAgIGNvdW50OiBvdXRwdXRcbiAgICB9O1xuICAgIHRoaXMud2luZG93LnBvc3RNZXNzYWdlKHNlbmRfZGF0YSwgXCIqXCIpO1xuICB9XG59XG5leHBvcnRzLlNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNXZWJDb25uZWN0b3IgPSBTbWFydEVtYmVkVHJhbnNmb3JtZXJzV2ViQ29ubmVjdG9yOyIsICJ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGluaXQpOyAvLyBsaXN0ZW4gZm9yIGluaXQgbWVzc2FnZVxuYXN5bmMgZnVuY3Rpb24gaW5pdChldmVudCkge1xuICBpZiAoZXZlbnQuZGF0YS50eXBlID09PSAnaW5pdCcpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGluaXQpOyAvLyByZW1vdmUgdGhpcyBldmVudCBsaXN0ZW5lclxuICAgIGNvbnN0IG1vZGVsX2NvbmZpZyA9IGV2ZW50LmRhdGEubW9kZWxfY29uZmlnX2tleTtcbiAgICBjb25zdCB7IFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNXZWJDb25uZWN0b3IgfSA9IGF3YWl0IGltcG9ydCgnLi9TbWFydEVtYmVkVHJhbnNmb3JtZXJzV2ViQ29ubmVjdG9yLmpzJyk7XG4gICAgY29uc3QgbW9kZWwgPSBhd2FpdCBTbWFydEVtYmVkVHJhbnNmb3JtZXJzV2ViQ29ubmVjdG9yLmNyZWF0ZShtb2RlbF9jb25maWcsIHdpbmRvdyk7XG4gICAgd2luZG93Lm1vZGVsID0gbW9kZWw7XG4gIH1cbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBLHlCQUFBQSxTQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLE1BQ0UseUJBQXlCO0FBQUEsUUFDdkIsWUFBYztBQUFBLFFBQ2QsWUFBYztBQUFBLFFBQ2QsTUFBUTtBQUFBLFFBQ1IsWUFBYztBQUFBLFFBQ2QsTUFBUTtBQUFBLFFBQ1IsYUFBZTtBQUFBLFFBQ2YsTUFBUTtBQUFBLE1BQ1Y7QUFBQSxNQUNBLGlDQUFpQztBQUFBLFFBQy9CLFlBQWM7QUFBQSxRQUNkLFlBQWM7QUFBQSxRQUNkLE1BQVE7QUFBQSxRQUNSLFlBQWM7QUFBQSxRQUNkLE1BQVE7QUFBQSxRQUNSLGFBQWU7QUFBQSxRQUNmLE1BQVE7QUFBQSxNQUNWO0FBQUEsTUFDQSwwQ0FBMEM7QUFBQSxRQUN4QyxZQUFjO0FBQUEsUUFDZCxZQUFjO0FBQUEsUUFDZCxNQUFRO0FBQUEsUUFDUixZQUFjO0FBQUEsUUFDZCxNQUFRO0FBQUEsUUFDUixhQUFlO0FBQUEsUUFDZixNQUFRO0FBQUEsTUFDVjtBQUFBLE1BQ0EsMEJBQTBCO0FBQUEsUUFDeEIsWUFBYztBQUFBLFFBQ2QsWUFBYztBQUFBLFFBQ2QsTUFBUTtBQUFBLFFBQ1IsWUFBYztBQUFBLFFBQ2QsTUFBUTtBQUFBLFFBQ1IsYUFBZTtBQUFBLFFBQ2YsTUFBUTtBQUFBLE1BQ1Y7QUFBQSxNQUNBLDBCQUEwQjtBQUFBLFFBQ3hCLFlBQWM7QUFBQSxRQUNkLFlBQWM7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\n"
}